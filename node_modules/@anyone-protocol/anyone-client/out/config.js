"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAnonConfigFile = createAnonConfigFile;
exports.createProxyConfigFile = createProxyConfigFile;
const promises_1 = __importDefault(require("fs/promises"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const readline_1 = __importDefault(require("readline"));
const utils_1 = require("./utils");
function askForAgreement() {
    return __awaiter(this, void 0, void 0, function* () {
        const rl = readline_1.default.createInterface({
            input: process.stdin,
            output: process.stdout
        });
        return new Promise((resolve) => {
            rl.question('Do you agree to the terms? (Press enter or y to agree, or ctrl-c to exit): ', (answer) => {
                rl.close();
                resolve(answer.toLowerCase() === 'y' || answer === '');
            });
        });
    });
}
function createAnonConfigFile(options) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (options.configFile) {
            try {
                yield promises_1.default.access(options.configFile);
                return options.configFile;
            }
            catch (_c) {
            }
        }
        const configPath = (_a = options.configFile) !== null && _a !== void 0 ? _a : path_1.default.join(os_1.default.tmpdir(), `anonrc-${Date.now()}`);
        const tempDataDirName = `anon-data-${Date.now()}`;
        const tempDataDirPath = path_1.default.join(os_1.default.tmpdir(), tempDataDirName);
        const binaryDir = (0, utils_1.getBinaryDir)();
        const configItems = [
            `DataDirectory ${tempDataDirPath}`,
            `SOCKSPort ${options.socksPort}`,
            `ORPort ${options.orPort}`,
            `ControlPort ${options.controlPort}`,
            `GeoIPFile ${path_1.default.join(binaryDir, 'geoip')}`,
            `GeoIPv6File ${path_1.default.join(binaryDir, 'geoip6')}`,
        ];
        yield promises_1.default.writeFile(configPath, configItems.join('\n') + '\n');
        yield promises_1.default.mkdir(tempDataDirPath, { recursive: true });
        const termsAgreementFileName = 'terms-agreement';
        const target = (_b = options.termsFilePath) !== null && _b !== void 0 ? _b : path_1.default.join(process.cwd(), termsAgreementFileName);
        if (fs_1.default.existsSync(target)) {
            const link = path_1.default.join(tempDataDirPath, termsAgreementFileName);
            yield promises_1.default.copyFile(target, link).catch((err) => {
                console.error(`Error copying terms agreement file: ${err}`);
            });
        }
        else {
            if (options.autoTermsAgreement) {
                yield promises_1.default.writeFile(target, 'agreed').catch((err) => {
                    console.error(`Error creating terms agreement file: ${err}`);
                });
                const link = path_1.default.join(tempDataDirPath, termsAgreementFileName);
                yield promises_1.default.copyFile(target, link).catch((err) => {
                    console.error(`Error copying terms agreement file: ${err}`);
                });
            }
            else {
                const agreed = yield askForAgreement();
                if (agreed) {
                    yield promises_1.default.writeFile(target, 'agreed').catch((err) => {
                        console.error(`Error creating terms agreement file: ${err}`);
                    });
                    const link = path_1.default.join(tempDataDirPath, termsAgreementFileName);
                    yield promises_1.default.copyFile(target, link).catch((err) => {
                        console.error(`Error copying terms agreement file: ${err}`);
                    });
                }
                else {
                    console.log('Agreement declined. Exiting...');
                    process.exit(1);
                }
            }
        }
        return configPath;
    });
}
function createProxyConfigFile(socksPort) {
    return __awaiter(this, void 0, void 0, function* () {
        const tempConfigName = `anon-proxy-${Date.now()}`;
        const tempConfigPath = path_1.default.join(os_1.default.tmpdir(), tempConfigName);
        let configItems = [
            'strict_chain',
            'proxy_dns',
            'remote_dns_subnet 224',
            '',
            'tcp_read_time_out 15000',
            'tcp_connect_time_out 8000',
            'localnet 127.0.0.0/255.0.0.0',
            '',
            '[ProxyList]',
            `socks5 127.0.0.1 ${socksPort !== null && socksPort !== void 0 ? socksPort : 9050}`,
        ];
        const configData = configItems.join("\n");
        yield promises_1.default.writeFile(tempConfigPath, configData);
        return tempConfigPath;
    });
}
