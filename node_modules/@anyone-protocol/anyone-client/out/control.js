"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Control = void 0;
const models_1 = require("./models");
const models_2 = require("./models");
const net = __importStar(require("net"));
const queue_1 = require("./queue");
const buffer_1 = require("buffer");
class Control {
    constructor(host = '127.0.0.1', port = 9051) {
        this.isAuthenticated = false;
        this.eventListeners = new Map();
        this.msgLock = new queue_1.AsyncQueue();
        this.replyQueue = new queue_1.AsyncQueue();
        this.eventQueue = new queue_1.AsyncQueue();
        this.eventNotice = new queue_1.AsyncEvent();
        this.readerLoopTask = null;
        this.eventLoopTask = null;
        console.log('Connecting to Anon Control Port at', host, port);
        this.client = net.createConnection({ host, port }, () => {
            console.log('Successfully connected to Anon Control Port');
        });
        this.createLoopTasks();
    }
    authenticate() {
        return __awaiter(this, arguments, void 0, function* (password = 'password') {
            const response = yield this.msg(`AUTHENTICATE "${password}"`);
            if (response.startsWith('250 OK')) {
                this.isAuthenticated = true;
                console.log('Authenticated to Anon Control Port');
            }
            else if (response.startsWith('515')) {
                throw new Error('Authentication failed');
            }
            else {
                throw new Error(`Unexpected response: ${response}`);
            }
        });
    }
    setEvents(events) {
        return __awaiter(this, void 0, void 0, function* () {
            const command = `SETEVENTS ${events.join(' ')}`;
            const response = yield this.msg(command);
            if (response.startsWith('250 OK')) {
                return true;
            }
            else {
                console.error('Error: ', response);
                return false;
            }
        });
    }
    circuitStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.msg('GETINFO circuit-status').then(response => {
                var _a, _b, _c, _d, _e;
                if (!response.startsWith('250+circuit-status=') && !response.startsWith('250 OK')) {
                    throw new Error('Invalid response format');
                }
                const cleanedResponse = response
                    .replace(/^250\+circuit-status=/, '')
                    .replace(/250 OK$/, '');
                const circuits = [];
                const lines = cleanedResponse.split('\n').filter(line => line.trim() !== '');
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    const parts = trimmedLine.split(' ');
                    if (parts.length < 4 || isNaN(parseInt(parts[0], 10))) {
                        continue;
                    }
                    const state = parts[1];
                    const circuitId = parseInt(parts[0], 10);
                    const relaysPart = ((_a = parts.find(part => part.startsWith('$'))) === null || _a === void 0 ? void 0 : _a.split(',')) || [];
                    const relays = relaysPart.map(relay => {
                        const [fingerprint, nickname] = relay.split('~');
                        return {
                            fingerprint: fingerprint.replace(/^\$/, ''),
                            nickname: nickname
                        };
                    });
                    const buildFlags = ((_c = (_b = parts.find(part => part.startsWith('BUILD_FLAGS='))) === null || _b === void 0 ? void 0 : _b.split('=')[1]) === null || _c === void 0 ? void 0 : _c.split(',')) || [];
                    const purpose = ((_d = parts.find(part => part.startsWith('PURPOSE='))) === null || _d === void 0 ? void 0 : _d.split('=')[1]) || '';
                    const timeCreated = new Date(((_e = parts.find(part => part.startsWith('TIME_CREATED='))) === null || _e === void 0 ? void 0 : _e.split('=')[1]) + 'Z' || ''); // Add Z to make it ISO 8601 compliant
                    const circuit = {
                        circuitId,
                        state,
                        relays,
                        buildFlags,
                        purpose,
                        timeCreated
                    };
                    circuits.push(circuit);
                }
                return circuits;
            });
        });
    }
    getCircuit(circuitId) {
        return __awaiter(this, void 0, void 0, function* () {
            const circuits = yield this.circuitStatus();
            const circuit = circuits.find(c => c.circuitId === circuitId);
            if (!circuit) {
                console.error(`Circuit with ID ${circuitId} not found`);
                throw new Error(`Circuit with ID ${circuitId} not found`);
            }
            return circuit;
        });
    }
    msg(message) {
        return __awaiter(this, void 0, void 0, function* () {
            // Acquire message lock
            yield this.msgLock.push();
            try {
                // Flush any old responses/errors in the reply queue
                while (!this.replyQueue.isEmpty) {
                    const response = yield this.replyQueue.pop();
                    if (response.includes('SocketClosed')) {
                        // This is expected sometimes
                        continue;
                    }
                    else if (response.includes('ProtocolError')) {
                        console.info('Tor provided a malformed message:', response);
                    }
                    else if (response.includes('ControllerError')) {
                        console.info('Socket experienced a problem:', response);
                    }
                    else {
                        console.info('Failed to deliver a response:', response);
                    }
                }
                // Send the message
                this.client.write(`${message}\r\n`);
                // Wait for reply
                const response = yield this.replyQueue.pop();
                // In a real implementation, you'd parse response objects here
                if (response.startsWith('5')) {
                    console.error('Error: ', response.substring(0, 100));
                }
                return response;
            }
            catch (err) {
                if (!this.client || this.client.destroyed) {
                    this.end();
                    throw new Error('SocketClosed');
                }
                throw err;
            }
            finally {
                yield this.msgLock.pop(); // Release lock
            }
        });
    }
    resolve(hostname) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.msg(`RESOLVE ${hostname}`);
        });
    }
    extendCircuit() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            var _a, _b, _c, _d;
            const circuitId = (_a = options.circuitId) !== null && _a !== void 0 ? _a : 0;
            const serverSpecs = (_b = options.serverSpecs) !== null && _b !== void 0 ? _b : [];
            const purpose = (_c = options.purpose) !== null && _c !== void 0 ? _c : 'general';
            const awaitBuild = (_d = options.awaitBuild) !== null && _d !== void 0 ? _d : false;
            var queue;
            var eventListener = null;
            if (awaitBuild) {
                queue = new queue_1.AsyncQueue();
                eventListener = (event) => {
                    if (event.type === models_1.EventType.CIRC) {
                        queue.push(event.data);
                    }
                };
                yield this.addEventListener(eventListener, models_1.EventType.CIRC);
            }
            let command = `EXTENDCIRCUIT ${circuitId}`;
            if (serverSpecs.length > 0) {
                command += ` ${serverSpecs.join(',')}`;
            }
            if (purpose) {
                command += ` purpose=${purpose}`;
            }
            const response = yield this.msg(command);
            if (!response.startsWith('250 EXTENDED')) {
                throw new Error('Failed to extend circuit');
            }
            const circId = response.split(' ')[2];
            if (awaitBuild) {
                var received = false;
                let numb = 0;
                while (!received) {
                    const event = yield queue.pop();
                    const id = event.split(' ')[0];
                    if (id === circId) {
                        console.log('Received event', event);
                        numb++;
                        if (numb >= serverSpecs.length) { // todo - fix this (we recevie event on each extended hop) 
                            received = true;
                        }
                    }
                }
                yield this.removeEventListener(eventListener);
            }
            return parseInt(circId, 10); // circuitId
        });
    }
    closeCircuit(circuitId) {
        return __awaiter(this, void 0, void 0, function* () {
            const command = `CLOSECIRCUIT ${circuitId}`;
            const response = yield this.msg(command);
            if (!response.startsWith('250')) {
                throw new Error(`Failed to close circuit: ${response}`);
            }
        });
    }
    getRelayInfo(fingerprint) {
        return __awaiter(this, void 0, void 0, function* () {
            const command = `GETINFO ns/id/$${fingerprint}`;
            const response = yield this.msg(command);
            if (!response.startsWith('250+ns/id/')) {
                throw new Error(`Failed to get relay address: ${response}`);
            }
            const lines = response.split('\n').map(line => line.trim());
            let flags = [];
            let ip = '';
            let orPort = 0;
            let bandwidth = 0;
            let nickname = '';
            for (const line of lines) {
                // Extract flags from the line starting with 's '
                if (line.startsWith('s ')) {
                    flags = line.substring(2).trim().split(' ').map(flag => models_2.Flag[flag]);
                }
                // Extract IP and ORPort from the line starting with 'r '
                if (line.startsWith('r ')) {
                    const parts = line.split(' ');
                    if (parts.length >= 7) {
                        nickname = parts[1];
                        ip = parts[6];
                        orPort = parseInt(parts[7], 10);
                    }
                }
                if (line.startsWith('w ')) {
                    bandwidth = parseInt(line.split('=')[1], 10);
                }
            }
            return { fingerprint, nickname, ip, orPort, flags, bandwidth };
        });
    }
    end() {
        this.client.write('QUIT\r\n');
        this.client.end();
    }
    disableStreamAttachment() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setConf('__LeaveStreamsUnattached', '1');
        });
    }
    enableStreamAttachment() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resetConf('__LeaveStreamsUnattached');
        });
    }
    disablePredictedCircuits() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setConf('__DisablePredictedCircuits', '1');
        });
    }
    enablePredictedCircuits() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resetConf('__DisablePredictedCircuits');
        });
    }
    setConf(param, value) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setOptions({ [param]: value }, false);
        });
    }
    resetConf(...params) {
        return __awaiter(this, void 0, void 0, function* () {
            const resetOptions = {};
            for (const param of params) {
                resetOptions[param] = null;
            }
            yield this.setOptions(resetOptions, true);
        });
    }
    setOptions(options, reset) {
        return __awaiter(this, void 0, void 0, function* () {
            const commandParts = [reset ? 'RESETCONF' : 'SETCONF'];
            for (const [key, val] of Object.entries(options)) {
                if (val === null || val === undefined) {
                    commandParts.push(key); // RESETCONF-style nulling
                }
                else if (typeof val === 'string') {
                    commandParts.push(`${key}="${val.trim()}"`);
                }
                else if (Array.isArray(val)) {
                    for (const item of val) {
                        commandParts.push(`${key}="${item.trim()}"`);
                    }
                }
                else {
                    throw new Error(`Invalid config value for ${key}: ${val}`);
                }
            }
            const command = commandParts.join(' ');
            const response = yield this.msg(command);
            if (!response.startsWith('250 OK')) {
                throw new Error(`SETCONF/RESETCONF failed: ${response}`);
            }
        });
    }
    attachStream(streamId, circuitId, exitingHop) {
        return __awaiter(this, void 0, void 0, function* () {
            let command = `ATTACHSTREAM ${streamId} ${circuitId}`;
            if (exitingHop !== undefined) {
                command += ` HOP=${exitingHop}`;
            }
            const response = yield this.msg(command);
            if (!response.startsWith('250')) {
                if (response.startsWith('552')) {
                    throw new Error(`InvalidRequest: ${response}`);
                }
                else if (response.startsWith('551')) {
                    throw new Error(`OperationFailed: ${response}`);
                }
                else if (response.startsWith('555')) {
                    throw new Error(`UnsatisfiableRequest: ${response}`);
                }
                else {
                    throw new Error(`ProtocolError: Unexpected ATTACHSTREAM response: ${response}`);
                }
            }
        });
    }
    attachListeners() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const setEvents = [];
            const failedEvents = [];
            if (!this.isAuthenticated || !this.client || this.client.destroyed) {
                return [setEvents, failedEvents];
            }
            const eventTypes = Array.from(((_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.keys()) || []);
            try {
                var isOk = yield this.setEvents(eventTypes);
                if (isOk) {
                    setEvents.push(...eventTypes);
                }
                else {
                    for (const eventType of eventTypes) {
                        isOk = yield this.setEvents([eventType]);
                        if (isOk) {
                            setEvents.push(eventType);
                        }
                        else {
                            failedEvents.push(eventType);
                        }
                    }
                }
            }
            catch (err) {
                console.error('Failed to attach listeners:', err);
                failedEvents.push(...eventTypes);
            }
            return [setEvents, failedEvents];
        });
    }
    attachEventListenersOrFail() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.eventListeners.size === 0) {
                return;
            }
            const [, failedEventTypes] = yield this.attachListeners();
            if (failedEventTypes.length > 0) {
                console.error('Failed to set events:', failedEventTypes);
                for (const event of failedEventTypes) {
                    const callbacks = this.eventListeners.get(event);
                    if (callbacks) {
                        this.eventListeners.delete(event);
                    }
                }
                throw new Error(`Failed to set events: ${failedEventTypes}`);
            }
        });
    }
    addEventListener(callback, ...eventTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const eventType of eventTypes) {
                var callbacks = this.eventListeners.get(eventType) || [];
                callbacks.push(callback);
                this.eventListeners.set(eventType, callbacks);
            }
            yield this.attachEventListenersOrFail();
        });
    }
    removeEventListener(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            var eventTypesChanged = false;
            for (const [eventType, callbacks] of this.eventListeners.entries()) {
                const index = callbacks.indexOf(callback);
                if (index !== -1) {
                    callbacks.splice(index, 1);
                }
                if (callbacks.length === 0) {
                    eventTypesChanged = true;
                    this.eventListeners.delete(eventType);
                }
            }
            if (eventTypesChanged) {
                yield this.attachEventListenersOrFail();
            }
        });
    }
    recv() {
        return new Promise((resolve, reject) => {
            let buffer = '';
            let rawLines = [];
            let statusCode = null;
            let divider = null;
            let inDataBlock = false;
            const onData = (data) => {
                buffer += data.toString();
                let lines = buffer.split('\r\n');
                buffer = lines.pop() || '';
                for (const line of lines) {
                    if (!statusCode) {
                        if (!/^\d{3}[ +\-]/.test(line)) {
                            cleanup();
                            return reject(new Error(`Malformed initial line: '${line}'`));
                        }
                        statusCode = line.substring(0, 3);
                        divider = line.charAt(3);
                    }
                    if (line.startsWith('..')) {
                        rawLines.push(line.slice(1));
                    }
                    else {
                        rawLines.push(line);
                    }
                    if (line.startsWith(statusCode + ' ')) {
                        cleanup();
                        return resolve(rawLines.join('\r\n'));
                    }
                    if (inDataBlock) {
                        if (line === '.') {
                            inDataBlock = false;
                            continue;
                        }
                    }
                    else {
                        switch (divider) {
                            case ' ':
                                cleanup();
                                return resolve(rawLines.join('\r\n'));
                            case '+':
                                inDataBlock = true;
                                break;
                            case '-':
                                continue;
                            default:
                                cleanup();
                                return reject(new Error(`Unknown divider: '${divider}' in line: ${line}`));
                        }
                    }
                }
            };
            const onError = (err) => {
                cleanup();
                reject(err);
            };
            const cleanup = () => {
                this.client.off('data', onData);
                this.client.off('error', onError);
            };
            this.client.on('data', onData);
            this.client.once('error', onError);
        });
    }
    createLoopTasks() {
        if (!this.readerLoopTask) {
            this.readerLoopTask = this.readerLoop();
        }
        if (!this.eventLoopTask) {
            this.eventLoopTask = this.eventLoop();
        }
    }
    readerLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.client && !this.client.destroyed) {
                try {
                    const message = yield this.recv();
                    if (message.startsWith('650')) {
                        // Asynchronous event
                        this.eventQueue.push(message.substring(4));
                        this.eventNotice.set();
                    }
                    else {
                        // Synchronous reply
                        this.replyQueue.push(message);
                    }
                }
                catch (err) {
                    this.replyQueue.push(err.toString());
                }
            }
        });
    }
    convertToEvent(eventMessage) {
        const parts = eventMessage.split(' ');
        const eventType = models_1.EventType[parts[0]];
        const eventData = parts.slice(1).join(' ');
        // Example parsing logic
        // You can customize this based on the actual event format
        switch (eventType) {
            case models_1.EventType.STREAM:
                const [streamId, status, circId, target, ...rest] = parts.slice(1);
                const keywordArgs = {};
                for (const arg of rest) {
                    const [key, value] = arg.split('=');
                    if (key && value !== undefined) {
                        keywordArgs[key.toUpperCase()] = value;
                    }
                }
                const event = {
                    type: eventType,
                    streamId: parseInt(streamId, 10),
                    status,
                    circId,
                    target,
                    sourceAddr: keywordArgs['SOURCE_ADDR'] || null,
                    purpose: keywordArgs['PURPOSE'] || null,
                    reason: keywordArgs['REASON'] || null,
                    remoteReason: keywordArgs['REMOTE_REASON'] || null,
                    source: keywordArgs['SOURCE'] || null
                };
                return event;
            case models_1.EventType.ADDRMAP:
                const [address, mappedAddress, expires] = parts.slice(1);
                const addrMapEvent = {
                    type: eventType,
                    address,
                    mappedAddress,
                    expires: expires ? new Date(expires) : undefined
                };
                return addrMapEvent;
            default:
                return {
                    type: eventType,
                    data: eventData,
                };
        }
    }
    handleEvent(eventMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            let event = null;
            let eventType;
            try {
                event = this.convertToEvent(eventMessage); // you’ll implement this parser
                eventType = event.type;
            }
            catch (err) {
                event = eventMessage;
                eventType = models_1.EventType.UNKNOWN;
                console.error(`Tor sent a malformed event (${err}):`, eventMessage);
            }
            // Dispatch to listeners
            const listeners = this.eventListeners.get(eventType);
            if (listeners) {
                for (const listener of listeners) {
                    try {
                        const result = listener(event);
                        if (result instanceof Promise) {
                            yield result;
                        }
                    }
                    catch (err) {
                        console.warn(`Event listener for ${eventType} raised an error:`, err);
                    }
                }
            }
        });
    }
    eventLoop() {
        return __awaiter(this, void 0, void 0, function* () {
            let socketClosedAt = null;
            while (true) {
                try {
                    const eventMessage = yield this.eventQueue.pop();
                    yield this.handleEvent(eventMessage);
                    if (!this.client || this.client.destroyed) {
                        if (!socketClosedAt) {
                            socketClosedAt = Date.now();
                        }
                        else if (Date.now() - socketClosedAt > 100) {
                            break;
                        }
                    }
                }
                catch (err) {
                    if (!this.client || this.client.destroyed)
                        break;
                    try {
                        yield Promise.race([
                            this.eventNotice.wait(),
                            new Promise(resolve => setTimeout(resolve, 50)),
                        ]);
                    }
                    catch (_a) { }
                    this.eventNotice.clear();
                }
            }
        });
    }
    getRelays() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.msg('GETINFO ns/all');
            if (!response.startsWith('250+ns/all=')) {
                throw new Error('Invalid response format');
            }
            const cleanedResponse = response
                .replace(/^250\+ns\/all=/, '')
                .replace(/250 OK$/, '')
                .trim();
            const relays = [];
            const lines = cleanedResponse.split('\n');
            let current = {};
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('r ')) {
                    if (current.fingerprint) {
                        relays.push(current);
                        current = {};
                    }
                    const [, nickname, fingerprint, , date, time, ip, orPort, dirPort] = trimmedLine.split(' ');
                    current.nickname = nickname;
                    current.fingerprint = this.base64ToHex(fingerprint);
                    current.published = new Date(`${date}T${time}Z`);
                    current.ip = ip;
                    current.orPort = parseInt(orPort, 10);
                    current.dirPort = parseInt(dirPort, 10);
                    current.flags = [];
                    current.bandwidth = 0;
                }
                else if (trimmedLine.startsWith('s ')) {
                    current.flags = trimmedLine.substring(2).split(' ').map(flag => models_2.Flag[flag]);
                }
                else if (trimmedLine.startsWith('w ')) {
                    const match = trimmedLine.match(/Bandwidth=(\d+)/);
                    if (match) {
                        current.bandwidth = parseInt(match[1], 10);
                    }
                }
            }
            if (current.fingerprint) {
                relays.push(current);
            }
            return relays;
        });
    }
    findFirstByCountry(relays, firstCount, ...countries) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (const relay of relays) {
                if (firstCount > 0 && result.length >= firstCount) {
                    break;
                }
                try {
                    const country = yield this.getCountry(relay.ip);
                    if (countries.includes(country)) {
                        result.push(relay);
                    }
                }
                catch (err) {
                    console.warn(`Failed to get country for ${relay.ip}:`, err);
                }
            }
            return result;
        });
    }
    getRelaysByCountries(...countries) {
        return __awaiter(this, void 0, void 0, function* () {
            const relays = yield this.getRelays();
            const result = [];
            for (const relay of relays) {
                try {
                    const country = yield this.getCountry(relay.ip);
                    if (countries.includes(country)) {
                        result.push(relay);
                    }
                }
                catch (err) {
                    console.warn(`Failed to get country for ${relay.ip}:`, err);
                }
            }
            return result;
        });
    }
    populateCountries(relays) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const relay of relays) {
                if (relay.country) {
                    continue;
                }
                try {
                    const country = yield this.getCountry(relay.ip);
                    relay.country = country;
                }
                catch (err) {
                    console.warn(`Failed to get country for ${relay.ip}:`, err);
                }
            }
        });
    }
    filterRelaysByCountries(relays, ...countries) {
        return __awaiter(this, void 0, void 0, function* () {
            countries = countries.map(country => country.toLowerCase());
            const result = [];
            for (const relay of relays) {
                try {
                    const country = yield this.getCountry(relay.ip);
                    if (countries.includes(country)) {
                        result.push(relay);
                    }
                }
                catch (err) {
                    console.warn(`Failed to get country for ${relay.ip}:`, err);
                }
            }
            return result;
        });
    }
    filterRelaysByFlags(relays, ...flags) {
        return relays.filter(relay => {
            return flags.every(flag => relay.flags.includes(flag));
        });
    }
    getCountry(address_1) {
        return __awaiter(this, arguments, void 0, function* (address, timeoutMs = 1000) {
            const msgPromise = this.msg(`GETINFO ip-to-country/${address}`);
            const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('getCountry timeout')), timeoutMs));
            const response = yield Promise.race([msgPromise, timeout]);
            if (!response.startsWith('250-ip-to-country/')) {
                throw new Error('Invalid response format');
            }
            const cleanedResponse = response
                .replace(/^250-ip-to-country\//, '')
                .replace(/250 OK$/, '')
                .trim();
            const parts = cleanedResponse.split('=');
            if (parts.length < 2) {
                throw new Error('Invalid response format');
            }
            return parts[1];
        });
    }
    base64ToHex(identity, checkIfFingerprint = true) {
        let decoded;
        try {
            decoded = buffer_1.Buffer.from(identity, 'base64');
        }
        catch (err) {
            throw new Error(`Unable to decode identity string '${identity}'`);
        }
        const hex = decoded.toString('hex').toUpperCase();
        if (checkIfFingerprint && !this.isValidFingerprint(hex)) {
            throw new Error(`Decoded '${identity}' to '${hex}', which isn't a valid fingerprint`);
        }
        return hex;
    }
    isValidFingerprint(hex) {
        return /^[A-F0-9]{40}$/.test(hex);
    }
}
exports.Control = Control;
