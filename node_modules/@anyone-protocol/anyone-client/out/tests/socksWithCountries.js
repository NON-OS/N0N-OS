"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const process_1 = require("../process");
const socks_1 = require("../socks");
const control_1 = require("../control");
const models_1 = require("../models");
const config = {
    routings: [
        { targetAddress: 'ip-api.com', exitCountries: ['de'] },
        { targetAddress: 'ipinfo.io', exitCountries: ['nl'] },
        { targetAddress: 'api.ipify.org', exitCountries: ['de'] },
    ]
};
class AnonRunner {
    constructor() {
        this.shuttingDown = false;
        this.routingMap = {};
        this.anon = new process_1.Process({ displayLog: true, socksPort: 9050, controlPort: 9051 });
        process.on('SIGINT', this.shutdown.bind(this));
        process.on('SIGTERM', this.shutdown.bind(this));
    }
    run() {
        return __awaiter(this, arguments, void 0, function* (singleRequest = false) {
            try {
                yield this.anon.start();
                this.control = new control_1.Control();
                console.log('Anon started');
                console.log('Starting Anon SDK process...');
                yield this.control.authenticate();
                const relays = yield this.control.getRelays();
                console.log('Relays:', relays.length);
                let exits = this.control.filterRelaysByFlags(relays, models_1.Flag.Exit, models_1.Flag.Stable, models_1.Flag.Running, models_1.Flag.Fast);
                exits = exits.filter((exit) => {
                    return !exit.flags.includes(models_1.Flag.BadExit);
                });
                console.log('Exits all:', exits.length);
                // Retry mechanism for GeoIP data
                let retries = 3;
                let success = false;
                while (retries > 0 && !success) {
                    try {
                        yield this.control.populateCountries(exits);
                        success = true;
                    }
                    catch (error) {
                        console.log(`GeoIP data not loaded, retrying... (${retries} attempts left)`);
                        retries--;
                        if (retries === 0) {
                            throw new Error('Failed to load GeoIP data after multiple attempts');
                        }
                        yield new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retry
                    }
                }
                const guards = this.control.filterRelaysByFlags(relays, models_1.Flag.Guard, models_1.Flag.Stable, models_1.Flag.Running, models_1.Flag.Fast);
                console.log('Guards:', guards.length);
                for (const route of config.routings) {
                    const exitsByCountry = exits.filter((exit) => {
                        return route.exitCountries.some((country) => exit.country === country);
                    });
                    console.log('Exits filtered:', exitsByCountry.length);
                    const exit = exitsByCountry[Math.floor(Math.random() * exitsByCountry.length)];
                    const guard = guards[Math.floor(Math.random() * guards.length)];
                    // Get middle relays (not guards or exits)
                    const middleRelays = relays.filter(relay => relay.flags.includes(models_1.Flag.Stable) &&
                        relay.flags.includes(models_1.Flag.Running) &&
                        !relay.flags.includes(models_1.Flag.Exit) &&
                        !relay.flags.includes(models_1.Flag.Guard));
                    const middle = middleRelays[Math.floor(Math.random() * middleRelays.length)];
                    // Create three-hop path
                    const path = [guard.fingerprint, middle.fingerprint, exit.fingerprint];
                    console.log('Path:', path);
                    const options = {
                        circuitId: 0,
                        serverSpecs: path,
                        purpose: "general",
                        awaitBuild: true
                    };
                    const circuitId = yield this.control.extendCircuit(options);
                    this.routingMap[route.targetAddress] = circuitId;
                }
                yield this.control.disableStreamAttachment();
                // add event listener
                const eventListener = (event) => __awaiter(this, void 0, void 0, function* () {
                    if (event.status === 'NEW') {
                        const targetAddress = event.target.split(':')[0];
                        const circuitId = this.routingMap[targetAddress];
                        if (circuitId && (event.circId === '0' || event.circId === undefined)) {
                            yield this.control.attachStream(event.streamId, circuitId);
                        }
                        else {
                            // Look for an existing open circuit first
                            const circuits = yield this.control.circuitStatus();
                            console.log('Circuits:', circuits);
                            const openCircuits = circuits.filter(circuit => circuit.state === 'BUILT' &&
                                circuit.purpose === 'GENERAL' &&
                                circuit.relays.length === 3);
                            if (openCircuits.length > 0) {
                                const randomCircuit = openCircuits[Math.floor(Math.random() * openCircuits.length)];
                                console.log(`Found ${openCircuits.length} open circuits, randomly selected circuit ${randomCircuit.circuitId}`);
                                yield this.control.attachStream(event.streamId, randomCircuit.circuitId);
                            }
                        }
                    }
                });
                yield this.control.addEventListener(eventListener, models_1.EventType.STREAM);
                // if (!singleRequest) {
                //     console.log('Anon VPN routing is active. Press Ctrl+C to quit.');
                //     await new Promise<void>((resolve) => {
                //         this._exitPromiseResolver = resolve;
                //     });
                // }
            }
            catch (error) {
                console.error('Error:', error);
                yield this.shutdown();
            }
        });
    }
    shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.shuttingDown)
                return;
            this.shuttingDown = true;
            console.log('Shutting down Anon SDK process...');
            try {
                if (this.control)
                    yield this.control.end();
                console.log('Anon SDK process shut down');
            }
            catch (e) {
                console.warn('Control shutdown error:', e);
            }
            try {
                yield this.anon.stop();
                console.log('Anon stopped');
            }
            catch (e) {
                console.warn('Anon shutdown error:', e);
            }
            if (this._exitPromiseResolver)
                this._exitPromiseResolver();
        });
    }
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const anonRunner = new AnonRunner();
        yield anonRunner.run(false);
        console.log('Anon SDK process started');
        const testSites = [
            'https://ipwho.is',
            'https://ipapi.co/json',
            'https://ipinfo.io/json',
            'https://ifconfig.me/all.json',
            'https://api.myip.com',
            'https://httpbin.org/ip',
            'https://api.ipify.org?format=json'
        ];
        try {
            const socks = new socks_1.Socks(anonRunner.anon);
            while (true) {
                const randomSite = testSites[Math.floor(Math.random() * testSites.length)];
                try {
                    console.log(`\nMaking request to: ${randomSite}`);
                    const response = yield socks.get(randomSite);
                    console.log('Response:', response.data);
                }
                catch (error) {
                    console.error(`Error requesting ${randomSite}:`, error);
                }
                // Wait between 1-3 seconds before next request
                yield new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
            }
        }
        catch (error) {
            console.error('Error:', error);
        }
        finally {
            yield anonRunner.shutdown();
        }
        process.on('uncaughtException', (err) => {
            console.error('Uncaught Exception:', err);
            process.exit(1);
        });
        process.on('unhandledRejection', (reason) => {
            console.error('Unhandled Rejection:', reason);
            process.exit(1);
        });
    });
}
main();
