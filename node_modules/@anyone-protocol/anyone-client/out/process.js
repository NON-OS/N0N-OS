"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Process = void 0;
const child_process_1 = require("child_process");
const config_1 = require("./config");
const utils_1 = require("./utils");
const chalk_1 = __importDefault(require("chalk"));
const child_process_2 = require("child_process");
const util_1 = require("util");
const errorTypes_1 = require("./errorTypes");
const execAsync = (0, util_1.promisify)(child_process_2.exec);
/**
 * Allows to run Anon client with different configuration options
 */
class Process {
    constructor(options) {
        this.options = {
            displayLog: false,
            useExecFile: false,
            socksPort: 9050,
            orPort: 0,
            controlPort: 9051,
            binaryPath: undefined,
            autoTermsAgreement: false,
            termsFilePath: undefined,
        };
        this.options = Object.assign(Object.assign({}, this.options), options);
    }
    /**
    * Retrieves the SOCKS port number configured for the Anon instance.
    *
    * @returns {number} The SOCKS port number.
    */
    getSOCKSPort() {
        return this.options.socksPort;
    }
    /**
     * Retrieves the Control port number configured for the Anon instance.
     *
     * @returns {number} The Control port number.
     */
    getControlPort() {
        return this.options.controlPort;
    }
    /**
     * Retrieves the OR (Onion Routing) port number configured for the Anon instance.
     *
     * @returns {number} The OR port number.
     */
    getORPort() {
        return this.options.orPort;
    }
    /**
     * Starts Anon client with options configured in constructor
     *
     * @returns {Promise<void>} Promise that resolves when Anon is started
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.process !== undefined) {
                throw new Error('Anon process already started');
            }
            const configPath = yield (0, config_1.createAnonConfigFile)(this.options);
            const binaryPath = (_a = this.options.binaryPath) !== null && _a !== void 0 ? _a : (0, utils_1.getBinaryPath)('anon');
            const isRunning = yield Process.isAnonProcessRunning();
            if (isRunning) {
                throw new errorTypes_1.AnonRunningError('An Anon process is already running');
            }
            return this.startWithTimeout(binaryPath, configPath);
        });
    }
    startWithTimeout(binaryPath, configPath) {
        return new Promise((resolve, reject) => {
            const { cleanup, timeoutId } = this.setupTimeoutHandler(reject);
            try {
                this.process = this.runBinary(binaryPath, configPath, () => this.onStop(), (percentage) => this.handleBootstrapProgess(percentage, resolve, timeoutId));
                this.attachProcessListeners(this.process, cleanup, reject);
            }
            catch (error) {
                cleanup();
                reject(error);
            }
        });
    }
    setupTimeoutHandler(reject) {
        const timeoutId = setTimeout(() => {
            reject(new Error('Anon failed to bootstrap within 60 seconds'));
        }, 60000);
        const cleanup = () => {
            clearTimeout(timeoutId);
            if (this.process) {
                this.process.kill();
                this.process = undefined;
            }
        };
        return { cleanup, timeoutId };
    }
    handleBootstrapProgess(percentage, resolve, timeoutId) {
        if (percentage === 100) {
            clearTimeout(timeoutId);
            resolve();
        }
    }
    attachProcessListeners(process, cleanup, reject) {
        var _a, _b;
        (_a = this.process) === null || _a === void 0 ? void 0 : _a.on('error', (error) => {
            cleanup();
            reject(error);
        });
        (_b = this.process) === null || _b === void 0 ? void 0 : _b.once('exit', (code) => {
            if (code !== 0 && code !== null) {
                cleanup();
                reject(new Error(`Anon process exited with code ${code}`));
            }
        });
    }
    /**
     * Checks if any Anon process is running on the system
     * @returns {Promise<boolean>} Promise that resolves to true if any Anon process is running
     */
    static isAnonProcessRunning() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { stdout } = yield execAsync('ps aux | grep anon | grep -v grep');
                return stdout.trim().length > 0;
            }
            catch (error) {
                return false;
            }
        });
    }
    /**
     * Kills all Anon processes on the system
     * @returns {Promise<boolean>} Promise that resolves to true if any Anon process was killed
     */
    static killAnonProcess() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // First get the process IDs
                const { stdout: psOutput } = yield execAsync('ps aux | grep anon | grep -v grep');
                const lines = psOutput.trim().split('\n');
                if (lines.length === 0 || (lines.length === 1 && lines[0].trim() === '')) {
                    return false;
                }
                // Extract PIDs and kill them
                const killedPids = [];
                for (const line of lines) {
                    const pid = parseInt(line.trim().split(/\s+/)[1], 10);
                    if (!isNaN(pid)) {
                        try {
                            process.kill(pid, 'SIGTERM');
                            killedPids.push(pid);
                            yield new Promise(resolve => setTimeout(resolve, 1000));
                            console.log(`Killed process ${pid}`);
                        }
                        catch (killError) {
                            console.error(`Failed to kill process ${pid}:`, killError);
                        }
                    }
                }
                console.log('Killed Anon processes with PIDs:', killedPids);
                return killedPids.length > 0;
            }
            catch (error) {
                console.error('Error killing Anon processes:', error);
                return false;
            }
        });
    }
    /**
     * Stops Anon client
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.process !== undefined) {
                this.process.kill('SIGTERM');
            }
        });
    }
    /**
     * Allows to check if Anon is running
     * @returns {boolean} true if Anon is running
     */
    isRunning() {
        return this.process !== undefined;
    }
    onStop() {
        this.process = undefined;
    }
    runBinary(binaryPath, configPath, onStop, onBootstrap) {
        var _a;
        let args = [];
        if (configPath !== undefined) {
            args = ['-f', configPath];
        }
        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.useExecFile) === true) {
            const child = (0, child_process_1.execFile)(binaryPath, args);
            child.on('close', () => {
                if (onStop !== undefined) {
                    onStop();
                }
            });
            child.on('exit', () => {
                if (onStop !== undefined) {
                    onStop();
                }
            });
            return child;
        }
        const child = (0, child_process_1.spawn)(binaryPath, args, { detached: false });
        child.stdout.on('data', (data) => {
            var _a;
            const logLines = data.toString().split('\n');
            for (const line of logLines) {
                const bootstrapMatch = line.match(/Bootstrapped (\d+)%.*?: (.+)/);
                const versionMatch = line.match(/Anon (\d+\.\d+\.\d+[\w.-]+) .* running on/);
                if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.displayLog) === true) {
                    console.log(line);
                    if (bootstrapMatch) {
                        const [, percentage, status] = bootstrapMatch;
                        if (onBootstrap) {
                            onBootstrap(parseInt(percentage, 10));
                        }
                    }
                }
                else {
                    const bootstrapMatch = line.match(/Bootstrapped (\d+)%.*?: (.+)/);
                    const versionMatch = line.match(/Anon (\d+\.\d+\.\d+[\w.-]+) .* running on/);
                    if (bootstrapMatch) {
                        const [, percentage, status] = bootstrapMatch;
                        const formattedPercentage = chalk_1.default.green(`${percentage}%`);
                        const formattedStatus = chalk_1.default.blue(status);
                        console.log(`Bootstrapped ${formattedPercentage}: ${formattedStatus}`);
                        if (onBootstrap) {
                            onBootstrap(parseInt(percentage, 10));
                        }
                    }
                    else if (line.match(/\[err\]/i)) {
                        console.log(chalk_1.default.red(line));
                    }
                    else if (versionMatch) {
                        const [, version] = versionMatch;
                        console.log(chalk_1.default.yellow(`Running Anon version ${version} `));
                    }
                }
            }
        });
        child.stderr.on('data', (data) => {
            var _a;
            if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.displayLog) === true) {
                console.log(`${data}`);
            }
        });
        child.on('close', () => {
            if (onStop !== undefined) {
                onStop();
            }
        });
        child.on('exit', () => {
            if (onStop !== undefined) {
                onStop();
            }
        });
        return child;
    }
}
exports.Process = Process;
